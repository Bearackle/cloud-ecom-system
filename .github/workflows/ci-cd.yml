name: Microservices CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  AKS_CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}
  AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}
  IMAGE_TAG: ${{ github.sha }}
  NAMESPACE: ecom

jobs:
  # ===== BUILD ALL MODULES (PARENT + COMMONS + ALL SERVICES) =====
  build-all-modules:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Install Third-Party Libraries
        run: |
          echo "===== Installing Baidu UID Generator ====="
          mvn install:install-file \
            -Dfile=libs/uid-generator-1.0.0-SNAPSHOT.jar \
            -DgroupId=com.baidu.fsg \
            -DartifactId=uid-generator \
            -Dversion=1.0.0-SNAPSHOT \
            -Dpackaging=jar \
            -DgeneratePom=true
          echo "‚úÖ Third-party libraries installed"

      - name: Build All Modules (Parent + Commons + Services)
        run: |
          echo "===== Building entire project ====="
          echo "This will build:"
          echo "  - Parent POM (ecom)"
          echo "  - commons module"
          echo "  - All microservices"
          echo ""
          
          # Build everything in one command
          mvn clean install -DskipTests
          
          echo ""
          echo "‚úÖ All modules built successfully!"
          echo ""
          echo "Built artifacts:"
          find . -name "*.jar" -not -path "*/original/*" | grep target

      - name: Run Tests
        run: |
          echo "===== Running tests for all modules ====="
          mvn test
        continue-on-error: true

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            **/target/*.jar
            !**/target/*-original.jar
          retention-days: 1

  # ===== BUILD AND PUSH DOCKER IMAGES =====
  docker-build-push:
    needs: build-all-modules
    runs-on: ubuntu-latest
    timeout-minutes: 20

    strategy:
      matrix:
        service:
          - api-gateway
          - auth-service
          - user-service
          - product-service
          - order-service
          - payment-service
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Verify JAR exists
        run: |
          echo "===== Checking JAR file for ${{ matrix.service }} ====="
          
          if [ -f "${{ matrix.service }}/target/${{ matrix.service }}-0.0.1-SNAPSHOT.jar" ]; then
            echo "‚úÖ JAR file found"
            ls -lh ${{ matrix.service }}/target/*.jar
          else
            echo "‚ùå JAR file not found!"
            echo "Available files in target:"
            ls -la ${{ matrix.service }}/target/ || echo "Target directory not found"
            exit 1
          fi

      - name: Azure Login
        uses: azure/login@v1
        timeout-minutes: 2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Build and Push Docker Image
        timeout-minutes: 10
        working-directory: ${{ matrix.service }}
        run: |
          echo "===== Building Docker Image for ${{ matrix.service }} ====="
          
          # Extract ACR name
          ACR_NAME=$(echo ${{ env.ACR_LOGIN_SERVER }} | cut -d'.' -f1)
          
          # Login to ACR
          az acr login --name $ACR_NAME
          
          # Build Docker image
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/${{ matrix.service }}:${{ env.IMAGE_TAG }} .
          
          # Push to ACR
          echo "===== Pushing to ACR ====="
          docker push ${{ env.ACR_LOGIN_SERVER }}/${{ matrix.service }}:${{ env.IMAGE_TAG }}
          
          echo "‚úÖ Successfully built and pushed ${{ matrix.service }}"

  # ===== DEPLOY ALL SERVICES TO AKS =====
  deploy-all:
    needs: docker-build-push
    runs-on: ubuntu-latest
    timeout-minutes: 20
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        timeout-minutes: 2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          echo "‚úÖ Namespace ready"

      - name: Create/Update ACR Secret
        run: |
          echo "===== Creating ACR pull secret ====="
          
          ACR_NAME=$(echo ${{ env.ACR_LOGIN_SERVER }} | cut -d'.' -f1)
          
          # Get ACR credentials
          ACR_USERNAME=$(az acr credential show --name $ACR_NAME --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name $ACR_NAME --query passwords[0].value -o tsv)
          
          # Create/update secret
          kubectl create secret docker-registry acr-secret \
            --docker-server=${{ env.ACR_LOGIN_SERVER }} \
            --docker-username=$ACR_USERNAME \
            --docker-password=$ACR_PASSWORD \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ ACR secret created/updated"

      - name: Update Kubernetes Manifests with New Image Tags
        run: |
          echo "===== Updating image tags to ${{ env.IMAGE_TAG }} ====="
          
          SERVICES=("api-gateway" "auth-service" "user-service" "product-service" "order-service" "payment-service")
          
          for service in "${SERVICES[@]}"; do
            DEPLOYMENT_FILE="k8s/${service}-deployment.yaml"
          
            if [ -f "$DEPLOYMENT_FILE" ]; then
              # Update image tag
              sed -i "s|image: ${ACR_LOGIN_SERVER}/${service}:.*|image: ${ACR_LOGIN_SERVER}/${service}:${IMAGE_TAG}|g" \
                "$DEPLOYMENT_FILE"
          
              echo "‚úÖ Updated ${service} to use tag ${IMAGE_TAG}"
            else
              echo "‚ö†Ô∏è  Deployment file not found: $DEPLOYMENT_FILE"
            fi
          done

      - name: Deploy ConfigMap
        run: |
          if [ -f k8s/configmap.yaml ]; then
            kubectl apply -f k8s/configmap.yaml -n ${{ env.NAMESPACE }}
            echo "‚úÖ ConfigMap applied"
          else
            echo "‚ö†Ô∏è  No ConfigMap found, skipping..."
          fi

      - name: Deploy Services in Order
        run: |
          echo "===== Deploying Microservices in Dependency Order ====="
          echo ""
          
          # Define deployment order (dependencies first)
          SERVICES=(
            "auth-service"
            "user-service"
            "product-service"
            "order-service"
            "payment-service"
            "api-gateway"
          )
          
          for service in "${SERVICES[@]}"; do
            echo "----------------------------------------"
            echo "Deploying: $service"
            echo "----------------------------------------"
          
            # Apply deployment
            kubectl apply -f k8s/${service}-deployment.yaml -n ${{ env.NAMESPACE }}
          
            # Wait for deployment to be ready (max 3 minutes)
            echo "Waiting for $service to be ready..."
            kubectl rollout status deployment/$service -n ${{ env.NAMESPACE }} --timeout=180s
          
            if [ $? -eq 0 ]; then
              echo "‚úÖ $service deployed successfully"
              echo ""
            else
              echo "‚ùå $service deployment failed"
          
              # Show debug info
              echo ""
              echo "Pod status:"
              kubectl get pods -n ${{ env.NAMESPACE }} -l app=$service
              echo ""
              echo "Recent events:"
              kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -10
          
              exit 1
            fi
          done
          
          echo "========================================="
          echo "‚úÖ All services deployed successfully!"
          echo "========================================="

      - name: Verify Deployment Status
        run: |
          echo ""
          echo "========================================="
          echo "         DEPLOYMENT VERIFICATION"
          echo "========================================="
          echo ""
          
          echo "üì¶ PODS:"
          echo "---------------------------------------"
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          echo ""
          
          echo "üåê SERVICES:"
          echo "---------------------------------------"
          kubectl get services -n ${{ env.NAMESPACE }}
          echo ""
          
          echo "üöÄ DEPLOYMENTS:"
          echo "---------------------------------------"
          kubectl get deployments -n ${{ env.NAMESPACE }}
          echo ""
          
          echo "üìä REPLICA SETS:"
          echo "---------------------------------------"
          kubectl get replicasets -n ${{ env.NAMESPACE }}
          echo ""

      - name: Get API Gateway URL
        run: |
          echo "========================================="
          echo "      API GATEWAY ACCESS INFO"
          echo "========================================="
          echo ""
          
          # Get service info
          kubectl get service api-gateway -n ${{ env.NAMESPACE }}
          echo ""
          
          # Try to get external IP
          EXTERNAL_IP=$(kubectl get service api-gateway -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          if [ -z "$EXTERNAL_IP" ]; then
            echo "‚è≥ External IP is being provisioned..."
            echo ""
            echo "Run this command in a few minutes to check:"
            echo "  kubectl get service api-gateway -n ${{ env.NAMESPACE }}"
          else
            echo "‚úÖ API Gateway is ready!"
            echo ""
            echo "üåê Access URL: http://$EXTERNAL_IP"
            echo ""
            echo "Test the API:"
            echo "  curl http://$EXTERNAL_IP/health"
          fi
          echo ""
          echo "========================================="

      - name: Display Useful Commands
        if: always()
        run: |
          echo ""
          echo "========================================="
          echo "       USEFUL KUBECTL COMMANDS"
          echo "========================================="
          echo ""
          echo "View logs:"
          echo "  kubectl logs -f deployment/<service-name> -n ${{ env.NAMESPACE }}"
          echo ""
          echo "Describe pod:"
          echo "  kubectl describe pod <pod-name> -n ${{ env.NAMESPACE }}"
          echo ""
          echo "Exec into pod:"
          echo "  kubectl exec -it <pod-name> -n ${{ env.NAMESPACE }} -- /bin/sh"
          echo ""
          echo "Check events:"
          echo "  kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp'"
          echo ""
          echo "Port forward (for testing):"
          echo "  kubectl port-forward service/api-gateway 8080:80 -n ${{ env.NAMESPACE }}"
          echo ""
          echo "========================================="